# file: scientific_calculator_app.py
# ---------------------------------
# Scientific calculator with:
# - Buttons AND keyboard input
# - Real numbers (decimals)
# - Percent, sqrt, power
# - Backspace / clear
# - Save history to a local JSON file with date+time
# - Click history to reload old calculations

from __future__ import annotations

import json
import math
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

import tkinter as tk
from tkinter import messagebox


# -----------------------------
# A "Calculation" is one saved entry in history.
# -----------------------------
@dataclass(frozen=True)
class Calculation:
    expression: str          # What the user typed, like "2+3*5"
    result: str              # The answer, like "17"
    timestamp_iso: str       # When it was saved (date+time text)


# -----------------------------
# HistoryStore is the "file manager" for saving/loading history.
# -----------------------------
class HistoryStore:
    def __init__(self, file_path: Path) -> None:
        self._file_path = file_path  # Where history is stored on disk

    def load(self) -> list[Calculation]:
        # If the file doesn't exist yet, history is empty.
        if not self._file_path.exists():
            return []

        try:
            # Read the JSON file as text.
            text = self._file_path.read_text(encoding="utf-8")

            # Convert JSON text -> Python list/dicts.
            raw_items = json.loads(text)

            # Convert each dict into a Calculation object.
            items: list[Calculation] = []
            for item in raw_items:
                items.append(
                    Calculation(
                        expression=str(item.get("expression", "")),
                        result=str(item.get("result", "")),
                        timestamp_iso=str(item.get("timestamp_iso", "")),
                    )
                )
            return items
        except Exception:
            # If file is broken, just ignore it.
            return []

    def save_all(self, items: list[Calculation]) -> None:
        # Make sure the folder exists.
        self._file_path.parent.mkdir(parents=True, exist_ok=True)

        # Convert objects -> dictionaries for JSON.
        data = [item.__dict__ for item in items]

        # Save pretty JSON so you can open it and read it.
        self._file_path.write_text(json.dumps(data, indent=2), encoding="utf-8")

    def append(self, items: list[Calculation], calc: Calculation) -> list[Calculation]:
        # Add one new calculation to the list and save everything.
        new_items = list(items)
        new_items.append(calc)
        self.save_all(new_items)
        return new_items


# -----------------------------
# CalculatorEngine is the "brain" that understands math.
# -----------------------------
class CalculatorEngine:
    def __init__(self) -> None:
        self._expression = ""                 # What the user is typing right now
        self._last_expression: Optional[str] = None  # Saved after "=" is pressed
        self._last_result: Optional[str] = None      # Saved after "=" is pressed

    @property
    def expression(self) -> str:
        return self._expression

    @property
    def last_expression(self) -> Optional[str]:
        return self._last_expression

    @property
    def last_result(self) -> Optional[str]:
        return self._last_result

    def clear(self) -> None:
        self._expression = ""

    def backspace(self) -> None:
        if self._expression:
            self._expression = self._expression[:-1]

    def append(self, token: str) -> None:
        self._expression += token

    def sqrt(self) -> None:
        # Wrap the current expression like sqrt( ... )
        if not self._expression:
            self._expression = "sqrt("
        else:
            self._expression = f"sqrt({self._expression})"

    def power(self) -> None:
        # We let users type "^", but Python uses "**".
        self._expression += "^"

    def _handle_percent(self, expr: str) -> str:
        """
        Turn 10% into (10/100)
        Example: 200*10% -> 200*(10/100)
        """
        output = ""
        i = 0
        while i < len(expr):
            if expr[i] == "%":
                # Find the number just before the % sign.
                j = len(output) - 1
                while j >= 0 and (output[j].isdigit() or output[j] == "."):
                    j -= 1
                number = output[j + 1 :]
                if not number:
                    raise ValueError("Percent needs a number before it")
                output = output[: j + 1]
                output += f"({number}/100)"
                i += 1
            else:
                output += expr[i]
                i += 1
        return output

    def evaluate(self) -> tuple[bool, str]:
        """
        Returns:
        - (True, result_text) if it worked
        - (False, error_message) if it failed
        """
        raw = self._expression.strip()
        if not raw:
            return False, "Nothing to calculate."

        try:
            # Convert ^ into Python power operator **.
            expr = raw.replace("^", "**")

            # Convert percentages into math form.
            expr = self._handle_percent(expr)

            # Only allow sqrt() from math.
            allowed = {"sqrt": math.sqrt}

            # Evaluate with no builtins for safety.
            value = eval(expr, {"__builtins__": {}}, allowed)

            # Format result nicely (avoid "5.0" if it is exactly 5).
            if isinstance(value, float) and value.is_integer():
                result = str(int(value))
            else:
                result = str(value)

            # Remember last calculation (for saving).
            self._last_expression = raw
            self._last_result = result

            # Common calculator behavior: replace expression with result.
            self._expression = result

            return True, result
        except ZeroDivisionError:
            return False, "Division by zero."
        except Exception:
            return False, "Invalid input."


# -----------------------------
# CalculatorApp is the "window" (GUI).
# -----------------------------
class CalculatorApp(tk.Tk):
    def __init__(self, store: HistoryStore) -> None:
        super().__init__()

        # Basic window setup.
        self.title("Scientific Calculator")
        self.resizable(False, False)

        # Create brain + storage.
        self.engine = CalculatorEngine()
        self.store = store
        self.history = self.store.load()

        # Tkinter variables automatically update widgets.
        self.display_var = tk.StringVar(value="")
        self.status_var = tk.StringVar(value="")

        # Build UI and keyboard support.
        self._build_ui()
        self._bind_keyboard()

        # Show existing history from file.
        self._refresh_history()

    # -------------------------
    # GUI building
    # -------------------------
    def _build_ui(self) -> None:
        # Display where expression/result is shown.
        display = tk.Entry(
            self,
            textvariable=self.display_var,
            font=("Arial", 18),
            justify="right",
            width=25,
        )
        display.grid(row=0, column=0, columnspan=4, padx=10, pady=10)

        # Status line shows errors.
        status = tk.Label(self, textvariable=self.status_var, fg="red", anchor="w")
        status.grid(row=1, column=0, columnspan=4, padx=10, sticky="w")

        # Buttons (text, command).
        buttons = [
            ("C", self.on_clear),
            ("⌫", self.on_backspace),
            ("%", lambda: self.on_token("%")),
            ("/", lambda: self.on_token("/")),
            ("7", lambda: self.on_token("7")),
            ("8", lambda: self.on_token("8")),
            ("9", lambda: self.on_token("9")),
            ("*", lambda: self.on_token("*")),
            ("4", lambda: self.on_token("4")),
            ("5", lambda: self.on_token("5")),
            ("6", lambda: self.on_token("6")),
            ("-", lambda: self.on_token("-")),
            ("1", lambda: self.on_token("1")),
            ("2", lambda: self.on_token("2")),
            ("3", lambda: self.on_token("3")),
            ("+", lambda: self.on_token("+")),
            ("0", lambda: self.on_token("0")),
            (".", lambda: self.on_token(".")),
            ("√", self.on_sqrt),
            ("^", self.on_power),
        ]

        # Place buttons in a grid.
        r = 2
        c = 0
        for text, cmd in buttons:
            tk.Button(self, text=text, width=6, height=2, command=cmd).grid(
                row=r, column=c, padx=5, pady=5
            )
            c += 1
            if c == 4:
                c = 0
                r += 1

        # Equals button.
        tk.Button(self, text="=", width=26, height=2, command=self.on_equals).grid(
            row=r, column=0, columnspan=4, padx=10, pady=(5, 5)
        )

        # Save button.
        tk.Button(self, text="Save", width=26, height=2, command=self.on_save).grid(
            row=r + 1, column=0, columnspan=4, padx=10, pady=(0, 10)
        )

        # History list on the right.
        tk.Label(self, text="Saved calculations:").grid(
            row=0, column=4, padx=(10, 10), pady=(10, 0), sticky="w"
        )

        self.history_list = tk.Listbox(self, width=42, height=16)
        self.history_list.grid(row=1, column=4, rowspan=7, padx=(10, 10), pady=(0, 10))
        self.history_list.bind("<<ListboxSelect>>", self.on_history_select)

        tk.Label(self, text="Keyboard: Enter=Equals, Esc=Clear, Backspace=⌫, s=Save, r=Sqrt").grid(
            row=r + 2, column=0, columnspan=5, padx=10, pady=(0, 10), sticky="w"
        )

    # -------------------------
    # Keyboard support
    # -------------------------
    def _bind_keyboard(self) -> None:
        # "bind_all" means: catch keys anywhere in the window.
        self.bind_all("<Key>", self._on_keypress)

    def _on_keypress(self, event: tk.Event) -> None:
        """
        This runs whenever you press a key.

        event.char: the typed character (like '1', '+', '.')
        event.keysym: the special name for keys (like 'Return', 'BackSpace', 'Escape')
        """
        keysym = event.keysym
        ch = event.char

        # Special keys first:
        if keysym == "Return":           # Enter key
            self.on_equals()
            return

        if keysym == "BackSpace":        # Backspace key
            self.on_backspace()
            return

        if keysym == "Escape":           # Escape key
            self.on_clear()
            return

        # Useful shortcuts:
        if ch in ("s", "S"):             # Press 's' to save
            self.on_save()
            return

        if ch in ("r", "R"):             # Press 'r' to apply sqrt
            self.on_sqrt()
            return

        # Normal typing keys we allow:
        allowed_chars = set("0123456789+-*/().%")
        if ch in allowed_chars:
            self.on_token(ch)
            return

        # Power key: many keyboards type '^' directly.
        if ch == "^":
            self.on_power()
            return

        # If it's something else, ignore it (no error spam).

    # -------------------------
    # Helper: update display
    # -------------------------
    def _refresh_display(self) -> None:
        self.display_var.set(self.engine.expression)

    # -------------------------
    # Button handlers (also used by keyboard)
    # -------------------------
    def on_token(self, token: str) -> None:
        self.status_var.set("")          # Clear error text
        self.engine.append(token)        # Add token to expression
        self._refresh_display()          # Update screen

    def on_clear(self) -> None:
        self.status_var.set("")
        self.engine.clear()
        self._refresh_display()

    def on_backspace(self) -> None:
        self.status_var.set("")
        self.engine.backspace()
        self._refresh_display()

    def on_sqrt(self) -> None:
        self.status_var.set("")
        self.engine.sqrt()
        self._refresh_display()

    def on_power(self) -> None:
        self.status_var.set("")
        self.engine.power()
        self._refresh_display()

    def on_equals(self) -> None:
        ok, msg = self.engine.evaluate()
        if ok:
            self.status_var.set("")
            self._refresh_display()
        else:
            self.status_var.set(msg)

    def on_save(self) -> None:
        # Need a completed calculation to save.
        if not self.engine.last_expression or self.engine.last_result is None:
            messagebox.showinfo("Nothing to save", "Press '=' first, then Save.")
            return

        calc = Calculation(
            expression=self.engine.last_expression,
            result=self.engine.last_result,
            timestamp_iso=datetime.now().isoformat(timespec="seconds"),
        )

        self.history = self.store.append(self.history, calc)
        self._refresh_history()
        messagebox.showinfo("Saved", "Saved to history.")

    # -------------------------
    # History UI
    # -------------------------
    def _refresh_history(self) -> None:
        self.history_list.delete(0, tk.END)
        for item in self.history:
            self.history_list.insert(
                tk.END, f"{item.timestamp_iso} | {item.expression} = {item.result}"
            )

    def on_history_select(self, _event: Any) -> None:
        sel = self.history_list.curselection()
        if not sel:
            return
        idx = int(sel[0])
        item = self.history[idx]
        self.status_var.set(f"Loaded from history: {item.timestamp_iso}")
        self.engine.clear()
        self.engine.append(item.expression)
        self._refresh_display()


# -----------------------------
# Where we store the history file on your Mac.
# -----------------------------
def default_history_path() -> Path:
    return Path.home() / ".scientific_calculator" / "history.json"


# -----------------------------
# Program starts here.
# -----------------------------
def main() -> None:
    store = HistoryStore(default_history_path())
    app = CalculatorApp(store)
    app.mainloop()


if __name__ == "__main__":
    main()
